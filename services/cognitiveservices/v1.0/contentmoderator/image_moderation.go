package contentmoderator

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-pipeline-go/pipeline"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
)

// ImageModerationClient is the you use the API to scan your content as it is generated. Content Moderator then
// processes your content and sends the results along with relevant information either back to your systems or to the
// built-in review tool. You can use this information to take decisions e.g. take it down, send to human judge, etc.
//
// When using the API, images need to have a minimum of 128 pixels and a maximum file size of 4MB.
// Text can be at most 1024 characters long.
// If the content passed to the text API or the image API exceeds the size limits, the API will return an error code
// that informs about the issue.
//
// This API is currently available in:
//
// * West US - westus.api.cognitive.microsoft.com
// * East US 2 - eastus2.api.cognitive.microsoft.com
// * West Central US - westcentralus.api.cognitive.microsoft.com
// * West Europe - westeurope.api.cognitive.microsoft.com
// * Southeast Asia - southeastasia.api.cognitive.microsoft.com .
type ImageModerationClient struct {
	ManagementClient
}

// NewImageModerationClient creates an instance of the ImageModerationClient client.
func NewImageModerationClient(url url.URL, p pipeline.Pipeline) ImageModerationClient {
	return ImageModerationClient{NewManagementClient(url, p)}
}

// EvaluateFileInput returns probabilities of the image containing racy or adult content.
//
// imageStream is the image file. imageStream will be closed upon successful return. Callers should ensure closure when
// receiving an error.cacheImage is whether to retain the submitted image for future use; defaults to false if omitted.
func (client ImageModerationClient) EvaluateFileInput(ctx context.Context, body io.ReadSeeker, cacheImage *bool) (*Evaluate, error) {
	if err := validate([]validation{
		{targetValue: imageStream,
			constraints: []constraint{{target: "imageStream", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.evaluateFileInputPreparer(body, cacheImage)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.evaluateFileInputResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Evaluate), err
}

// evaluateFileInputPreparer prepares the EvaluateFileInput request.
func (client ImageModerationClient) evaluateFileInputPreparer(body io.ReadSeeker, cacheImage *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, body)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// evaluateFileInputResponder handles the response to the EvaluateFileInput request.
func (client ImageModerationClient) evaluateFileInputResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Evaluate{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// EvaluateMethod returns probabilities of the image containing racy or adult content.
//
// cacheImage is whether to retain the submitted image for future use; defaults to false if omitted.
func (client ImageModerationClient) EvaluateMethod(ctx context.Context, cacheImage *bool) (*Evaluate, error) {
	req, err := client.evaluateMethodPreparer(cacheImage)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.evaluateMethodResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Evaluate), err
}

// evaluateMethodPreparer prepares the EvaluateMethod request.
func (client ImageModerationClient) evaluateMethodPreparer(cacheImage *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// evaluateMethodResponder handles the response to the EvaluateMethod request.
func (client ImageModerationClient) evaluateMethodResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Evaluate{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// EvaluateURLInput returns probabilities of the image containing racy or adult content.
//
// contentType is the content type. imageURL is the image url. cacheImage is whether to retain the submitted image for
// future use; defaults to false if omitted.
func (client ImageModerationClient) EvaluateURLInput(ctx context.Context, contentType string, imageURL ImageURL, cacheImage *bool) (*Evaluate, error) {
	req, err := client.evaluateURLInputPreparer(contentType, imageURL, cacheImage)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.evaluateURLInputResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Evaluate), err
}

// evaluateURLInputPreparer prepares the EvaluateURLInput request.
func (client ImageModerationClient) evaluateURLInputPreparer(contentType string, imageURL ImageURL, cacheImage *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	req.URL.RawQuery = params.Encode()
	req.Header.Set("Content-Type", contentType)
	b, err := json.Marshal(imageURL)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// evaluateURLInputResponder handles the response to the EvaluateURLInput request.
func (client ImageModerationClient) evaluateURLInputResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Evaluate{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// FindFaces returns the list of faces found.
//
// cacheImage is whether to retain the submitted image for future use; defaults to false if omitted.
func (client ImageModerationClient) FindFaces(ctx context.Context, cacheImage *bool) (*FoundFaces, error) {
	req, err := client.findFacesPreparer(cacheImage)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.findFacesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*FoundFaces), err
}

// findFacesPreparer prepares the FindFaces request.
func (client ImageModerationClient) findFacesPreparer(cacheImage *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// findFacesResponder handles the response to the FindFaces request.
func (client ImageModerationClient) findFacesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &FoundFaces{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// FindFacesFileInput returns the list of faces found.
//
// imageStream is the image file. imageStream will be closed upon successful return. Callers should ensure closure when
// receiving an error.cacheImage is whether to retain the submitted image for future use; defaults to false if omitted.
func (client ImageModerationClient) FindFacesFileInput(ctx context.Context, body io.ReadSeeker, cacheImage *bool) (*FoundFaces, error) {
	if err := validate([]validation{
		{targetValue: imageStream,
			constraints: []constraint{{target: "imageStream", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.findFacesFileInputPreparer(body, cacheImage)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.findFacesFileInputResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*FoundFaces), err
}

// findFacesFileInputPreparer prepares the FindFacesFileInput request.
func (client ImageModerationClient) findFacesFileInputPreparer(body io.ReadSeeker, cacheImage *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, body)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// findFacesFileInputResponder handles the response to the FindFacesFileInput request.
func (client ImageModerationClient) findFacesFileInputResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &FoundFaces{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// FindFacesURLInput returns the list of faces found.
//
// contentType is the content type. imageURL is the image url. cacheImage is whether to retain the submitted image for
// future use; defaults to false if omitted.
func (client ImageModerationClient) FindFacesURLInput(ctx context.Context, contentType string, imageURL ImageURL, cacheImage *bool) (*FoundFaces, error) {
	req, err := client.findFacesURLInputPreparer(contentType, imageURL, cacheImage)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.findFacesURLInputResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*FoundFaces), err
}

// findFacesURLInputPreparer prepares the FindFacesURLInput request.
func (client ImageModerationClient) findFacesURLInputPreparer(contentType string, imageURL ImageURL, cacheImage *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	req.URL.RawQuery = params.Encode()
	req.Header.Set("Content-Type", contentType)
	b, err := json.Marshal(imageURL)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// findFacesURLInputResponder handles the response to the FindFacesURLInput request.
func (client ImageModerationClient) findFacesURLInputResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &FoundFaces{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// MatchFileInput fuzzily match an image against one of your custom Image Lists. You can create and manage your custom
// image lists using <a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe">this</a>
// API.
//
// Returns ID and tags of matching image.<br/>
// <br/>
// Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the
// response.
//
// imageStream is the image file. imageStream will be closed upon successful return. Callers should ensure closure when
// receiving an error.listID is the list Id. cacheImage is whether to retain the submitted image for future use;
// defaults to false if omitted.
func (client ImageModerationClient) MatchFileInput(ctx context.Context, body io.ReadSeeker, listID *string, cacheImage *bool) (*MatchResponse, error) {
	if err := validate([]validation{
		{targetValue: imageStream,
			constraints: []constraint{{target: "imageStream", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.matchFileInputPreparer(body, listID, cacheImage)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.matchFileInputResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*MatchResponse), err
}

// matchFileInputPreparer prepares the MatchFileInput request.
func (client ImageModerationClient) matchFileInputPreparer(body io.ReadSeeker, listID *string, cacheImage *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, body)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if listID != nil {
		params.Set("listId", *listID)
	}
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// matchFileInputResponder handles the response to the MatchFileInput request.
func (client ImageModerationClient) matchFileInputResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &MatchResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// MatchMethod fuzzily match an image against one of your custom Image Lists. You can create and manage your custom
// image lists using <a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe">this</a>
// API.
//
// Returns ID and tags of matching image.<br/>
// <br/>
// Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the
// response.
//
// listID is the list Id. cacheImage is whether to retain the submitted image for future use; defaults to false if
// omitted.
func (client ImageModerationClient) MatchMethod(ctx context.Context, listID *string, cacheImage *bool) (*MatchResponse, error) {
	req, err := client.matchMethodPreparer(listID, cacheImage)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.matchMethodResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*MatchResponse), err
}

// matchMethodPreparer prepares the MatchMethod request.
func (client ImageModerationClient) matchMethodPreparer(listID *string, cacheImage *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if listID != nil {
		params.Set("listId", *listID)
	}
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// matchMethodResponder handles the response to the MatchMethod request.
func (client ImageModerationClient) matchMethodResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &MatchResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// MatchURLInput fuzzily match an image against one of your custom Image Lists. You can create and manage your custom
// image lists using <a href="/docs/services/578ff44d2703741568569ab9/operations/578ff7b12703741568569abe">this</a>
// API.
//
// Returns ID and tags of matching image.<br/>
// <br/>
// Note: Refresh Index must be run on the corresponding Image List before additions and removals are reflected in the
// response.
//
// contentType is the content type. imageURL is the image url. listID is the list Id. cacheImage is whether to retain
// the submitted image for future use; defaults to false if omitted.
func (client ImageModerationClient) MatchURLInput(ctx context.Context, contentType string, imageURL ImageURL, listID *string, cacheImage *bool) (*MatchResponse, error) {
	req, err := client.matchURLInputPreparer(contentType, imageURL, listID, cacheImage)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.matchURLInputResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*MatchResponse), err
}

// matchURLInputPreparer prepares the MatchURLInput request.
func (client ImageModerationClient) matchURLInputPreparer(contentType string, imageURL ImageURL, listID *string, cacheImage *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if listID != nil {
		params.Set("listId", *listID)
	}
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	req.URL.RawQuery = params.Encode()
	req.Header.Set("Content-Type", contentType)
	b, err := json.Marshal(imageURL)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// matchURLInputResponder handles the response to the MatchURLInput request.
func (client ImageModerationClient) matchURLInputResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &MatchResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// OCRFileInput returns any text found in the image for the language specified. If no language is specified in input
// then the detection defaults to English.
//
// language is language of the terms. imageStream is the image file. imageStream will be closed upon successful return.
// Callers should ensure closure when receiving an error.cacheImage is whether to retain the submitted image for future
// use; defaults to false if omitted. enhanced is when set to True, the image goes through additional processing to
// come with additional candidates.
//
// image/tiff is not supported when enhanced is set to true
//
// Note: This impacts the response time.
func (client ImageModerationClient) OCRFileInput(ctx context.Context, language string, body io.ReadSeeker, cacheImage *bool, enhanced *bool) (*OCR, error) {
	if err := validate([]validation{
		{targetValue: imageStream,
			constraints: []constraint{{target: "imageStream", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.oCRFileInputPreparer(language, body, cacheImage, enhanced)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.oCRFileInputResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*OCR), err
}

// oCRFileInputPreparer prepares the OCRFileInput request.
func (client ImageModerationClient) oCRFileInputPreparer(language string, body io.ReadSeeker, cacheImage *bool, enhanced *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, body)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("language", language)
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	if enhanced != nil {
		params.Set("enhanced", fmt.Sprintf("%v", *enhanced))
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// oCRFileInputResponder handles the response to the OCRFileInput request.
func (client ImageModerationClient) oCRFileInputResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &OCR{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// OCRMethod returns any text found in the image for the language specified. If no language is specified in input then
// the detection defaults to English.
//
// language is language of the terms. cacheImage is whether to retain the submitted image for future use; defaults to
// false if omitted. enhanced is when set to True, the image goes through additional processing to come with additional
// candidates.
//
// image/tiff is not supported when enhanced is set to true
//
// Note: This impacts the response time.
func (client ImageModerationClient) OCRMethod(ctx context.Context, language string, cacheImage *bool, enhanced *bool) (*OCR, error) {
	req, err := client.oCRMethodPreparer(language, cacheImage, enhanced)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.oCRMethodResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*OCR), err
}

// oCRMethodPreparer prepares the OCRMethod request.
func (client ImageModerationClient) oCRMethodPreparer(language string, cacheImage *bool, enhanced *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("language", language)
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	if enhanced != nil {
		params.Set("enhanced", fmt.Sprintf("%v", *enhanced))
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// oCRMethodResponder handles the response to the OCRMethod request.
func (client ImageModerationClient) oCRMethodResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &OCR{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// OCRURLInput returns any text found in the image for the language specified. If no language is specified in input
// then the detection defaults to English.
//
// language is language of the terms. contentType is the content type. imageURL is the image url. cacheImage is whether
// to retain the submitted image for future use; defaults to false if omitted. enhanced is when set to True, the image
// goes through additional processing to come with additional candidates.
//
// image/tiff is not supported when enhanced is set to true
//
// Note: This impacts the response time.
func (client ImageModerationClient) OCRURLInput(ctx context.Context, language string, contentType string, imageURL ImageURL, cacheImage *bool, enhanced *bool) (*OCR, error) {
	req, err := client.oCRURLInputPreparer(language, contentType, imageURL, cacheImage, enhanced)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.oCRURLInputResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*OCR), err
}

// oCRURLInputPreparer prepares the OCRURLInput request.
func (client ImageModerationClient) oCRURLInputPreparer(language string, contentType string, imageURL ImageURL, cacheImage *bool, enhanced *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("language", language)
	if cacheImage != nil {
		params.Set("CacheImage", fmt.Sprintf("%v", *cacheImage))
	}
	if enhanced != nil {
		params.Set("enhanced", fmt.Sprintf("%v", *enhanced))
	}
	req.URL.RawQuery = params.Encode()
	req.Header.Set("Content-Type", contentType)
	b, err := json.Marshal(imageURL)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// oCRURLInputResponder handles the response to the OCRURLInput request.
func (client ImageModerationClient) oCRURLInputResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &OCR{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}
