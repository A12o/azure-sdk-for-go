package contentmoderator

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-pipeline-go/pipeline"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
)

// ReviewsClient is the you use the API to scan your content as it is generated. Content Moderator then processes your
// content and sends the results along with relevant information either back to your systems or to the built-in review
// tool. You can use this information to take decisions e.g. take it down, send to human judge, etc.
//
// When using the API, images need to have a minimum of 128 pixels and a maximum file size of 4MB.
// Text can be at most 1024 characters long.
// If the content passed to the text API or the image API exceeds the size limits, the API will return an error code
// that informs about the issue.
//
// This API is currently available in:
//
// * West US - westus.api.cognitive.microsoft.com
// * East US 2 - eastus2.api.cognitive.microsoft.com
// * West Central US - westcentralus.api.cognitive.microsoft.com
// * West Europe - westeurope.api.cognitive.microsoft.com
// * Southeast Asia - southeastasia.api.cognitive.microsoft.com .
type ReviewsClient struct {
	ManagementClient
}

// NewReviewsClient creates an instance of the ReviewsClient client.
func NewReviewsClient(url url.URL, p pipeline.Pipeline) ReviewsClient {
	return ReviewsClient{NewManagementClient(url, p)}
}

// AddVideoFrame the reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results
// of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.
//
// <h3>CallBack Schemas </h3>
// <h4>Review Completion CallBack Sample</h4>
// <p>
// {<br/>
// "ReviewId": "<Review Id>",<br/>
// "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
// "ModifiedBy": "<Name of the Reviewer>",<br/>
// "CallBackType": "Review",<br/>
// "ContentId": "<The ContentId that was specified input>",<br/>
// "Metadata": {<br/>
// "adultscore": "0.xxx",<br/>
// "a": "False",<br/>
// "racyscore": "0.xxx",<br/>
// "r": "True"<br/>
// },<br/>
// "ReviewerResultTags": {<br/>
// "a": "False",<br/>
// "r": "True"<br/>
// }<br/>
// }<br/>
//
// </p>.
//
// teamName is your team name. reviewID is id of the review. timescale is timescale of the video you are adding frames
// to.
func (client ReviewsClient) AddVideoFrame(ctx context.Context, teamName string, reviewID string, timescale *int32) (*http.Response, error) {
	req, err := client.addVideoFramePreparer(teamName, reviewID, timescale)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.addVideoFrameResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// addVideoFramePreparer prepares the AddVideoFrame request.
func (client ReviewsClient) addVideoFramePreparer(teamName string, reviewID string, timescale *int32) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if timescale != nil {
		params.Set("timescale", fmt.Sprintf("%v", *timescale))
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// addVideoFrameResponder handles the response to the AddVideoFrame request.
func (client ReviewsClient) addVideoFrameResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// AddVideoFrameStream use this method to add frames for a video review.Timescale: This parameter is a factor which is
// used to convert the timestamp on a frame into milliseconds. Timescale is provided in the output of the Content
// Moderator video media processor on the Azure Media Services platform.Timescale in the Video Moderation output is
// Ticks/Second.
//
// contentType is the content type. teamName is your team name. reviewID is id of the review. frameImageZip is zip file
// containing frame images. frameImageZip will be closed upon successful return. Callers should ensure closure when
// receiving an error.frameMetadata is metadata of the frame. timescale is timescale of the video .
func (client ReviewsClient) AddVideoFrameStream(ctx context.Context, contentType string, teamName string, reviewID string, body io.ReadSeeker, frameMetadata string, timescale *int32) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: frameImageZip,
			constraints: []constraint{{target: "frameImageZip", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.addVideoFrameStreamPreparer(contentType, teamName, reviewID, body, frameMetadata, timescale)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.addVideoFrameStreamResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// addVideoFrameStreamPreparer prepares the AddVideoFrameStream request.
func (client ReviewsClient) addVideoFrameStreamPreparer(contentType string, teamName string, reviewID string, body io.ReadSeeker, frameMetadata string, timescale *int32) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if timescale != nil {
		params.Set("timescale", fmt.Sprintf("%v", *timescale))
	}
	req.URL.RawQuery = params.Encode()
	req.Header.Set("Content-Type", contentType)
	return req, nil
}

// addVideoFrameStreamResponder handles the response to the AddVideoFrameStream request.
func (client ReviewsClient) addVideoFrameStreamResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusNoContent)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// AddVideoFrameURL use this method to add frames for a video review.Timescale: This parameter is a factor which is
// used to convert the timestamp on a frame into milliseconds. Timescale is provided in the output of the Content
// Moderator video media processor on the Azure Media Services platform.Timescale in the Video Moderation output is
// Ticks/Second.
//
// contentType is the content type. teamName is your team name. reviewID is id of the review. videoFrameBody is body
// for add video frames API timescale is timescale of the video.
func (client ReviewsClient) AddVideoFrameURL(ctx context.Context, contentType string, teamName string, reviewID string, videoFrameBody []VideoFrameBodyItem, timescale *int32) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: videoFrameBody,
			constraints: []constraint{{target: "videoFrameBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.addVideoFrameURLPreparer(contentType, teamName, reviewID, videoFrameBody, timescale)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.addVideoFrameURLResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// addVideoFrameURLPreparer prepares the AddVideoFrameURL request.
func (client ReviewsClient) addVideoFrameURLPreparer(contentType string, teamName string, reviewID string, videoFrameBody []VideoFrameBodyItem, timescale *int32) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if timescale != nil {
		params.Set("timescale", fmt.Sprintf("%v", *timescale))
	}
	req.URL.RawQuery = params.Encode()
	req.Header.Set("Content-Type", contentType)
	b, err := json.Marshal(videoFrameBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// addVideoFrameURLResponder handles the response to the AddVideoFrameURL request.
func (client ReviewsClient) addVideoFrameURLResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusNoContent)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// AddVideoTranscript this API adds a transcript file (text version of all the words spoken in a video) to a video
// review. The file should be a valid WebVTT format.
//
// teamName is your team name. reviewID is id of the review. contentType is the content type. vttfile is transcript
// file of the video. vttfile will be closed upon successful return. Callers should ensure closure when receiving an
// error.
func (client ReviewsClient) AddVideoTranscript(ctx context.Context, teamName string, reviewID string, contentType string, body io.ReadSeeker) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: vttfile,
			constraints: []constraint{{target: "vttfile", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.addVideoTranscriptPreparer(teamName, reviewID, contentType, body)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.addVideoTranscriptResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// addVideoTranscriptPreparer prepares the AddVideoTranscript request.
func (client ReviewsClient) addVideoTranscriptPreparer(teamName string, reviewID string, contentType string, body io.ReadSeeker) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PUT", client.url, body)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	req.Header.Set("Content-Type", contentType)
	return req, nil
}

// addVideoTranscriptResponder handles the response to the AddVideoTranscript request.
func (client ReviewsClient) addVideoTranscriptResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusNoContent)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// AddVideoTranscriptModerationResult this API adds a transcript screen text result file for a video review. Transcript
// screen text result file is a result of Screen Text API . In order to generate transcript screen text result file , a
// transcript file has to be screened for profanity using Screen Text API.
//
// contentType is the content type. teamName is your team name. reviewID is id of the review. transcriptModerationBody
// is body for add video transcript moderation result API
func (client ReviewsClient) AddVideoTranscriptModerationResult(ctx context.Context, contentType string, teamName string, reviewID string, transcriptModerationBody []TranscriptModerationBodyItem) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: transcriptModerationBody,
			constraints: []constraint{{target: "transcriptModerationBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.addVideoTranscriptModerationResultPreparer(contentType, teamName, reviewID, transcriptModerationBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.addVideoTranscriptModerationResultResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// addVideoTranscriptModerationResultPreparer prepares the AddVideoTranscriptModerationResult request.
func (client ReviewsClient) addVideoTranscriptModerationResultPreparer(contentType string, teamName string, reviewID string, transcriptModerationBody []TranscriptModerationBodyItem) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PUT", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	req.Header.Set("Content-Type", contentType)
	b, err := json.Marshal(transcriptModerationBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// addVideoTranscriptModerationResultResponder handles the response to the AddVideoTranscriptModerationResult request.
func (client ReviewsClient) addVideoTranscriptModerationResultResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusNoContent)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// CreateJob a job Id will be returned for the content posted on this endpoint.
//
// Once the content is evaluated against the Workflow provided the review will be created or ignored based on the
// workflow expression.
//
// <h3>CallBack Schemas </h3>
//
// <p>
// <h4>Job Completion CallBack Sample</h4><br/>
//
// {<br/>
// "JobId": "<Job Id>,<br/>
// "ReviewId": "<Review Id, if the Job resulted in a Review to be created>",<br/>
// "WorkFlowId": "default",<br/>
// "Status": "<This will be one of Complete, InProgress, Error>",<br/>
// "ContentType": "Image",<br/>
// "ContentId": "<This is the ContentId that was specified on input>",<br/>
// "CallBackType": "Job",<br/>
// "Metadata": {<br/>
// "adultscore": "0.xxx",<br/>
// "a": "False",<br/>
// "racyscore": "0.xxx",<br/>
// "r": "True"<br/>
// }<br/>
// }<br/>
//
// </p>
// <p>
// <h4>Review Completion CallBack Sample</h4><br/>
//
// {
// "ReviewId": "<Review Id>",<br/>
// "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
// "ModifiedBy": "<Name of the Reviewer>",<br/>
// "CallBackType": "Review",<br/>
// "ContentId": "<The ContentId that was specified input>",<br/>
// "Metadata": {<br/>
// "adultscore": "0.xxx",
// "a": "False",<br/>
// "racyscore": "0.xxx",<br/>
// "r": "True"<br/>
// },<br/>
// "ReviewerResultTags": {<br/>
// "a": "False",<br/>
// "r": "True"<br/>
// }<br/>
// }<br/>
//
// </p>.
//
// teamName is your team name. contentType is image, Text or Video. contentID is id/Name to identify the content
// submitted. workflowName is workflow Name that you want to invoke. jobContentType is the content type. content is
// content to evaluate. callBackEndpoint is callback endpoint for posting the create job result.
func (client ReviewsClient) CreateJob(ctx context.Context, teamName string, contentType string, contentID string, workflowName string, jobContentType string, content Content, callBackEndpoint *string) (*JobID, error) {
	if err := validate([]validation{
		{targetValue: content,
			constraints: []constraint{{target: "content.ContentValue", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.createJobPreparer(teamName, contentType, contentID, workflowName, jobContentType, content, callBackEndpoint)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.createJobResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*JobID), err
}

// createJobPreparer prepares the CreateJob request.
func (client ReviewsClient) createJobPreparer(teamName string, contentType string, contentID string, workflowName string, jobContentType string, content Content, callBackEndpoint *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("ContentType", fmt.Sprintf("%v", contentType))
	params.Set("ContentId", contentID)
	params.Set("WorkflowName", workflowName)
	if callBackEndpoint != nil {
		params.Set("CallBackEndpoint", *callBackEndpoint)
	}
	req.URL.RawQuery = params.Encode()
	req.Header.Set("Content-Type", fmt.Sprintf("%v", jobContentType))
	b, err := json.Marshal(content)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// createJobResponder handles the response to the CreateJob request.
func (client ReviewsClient) createJobResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &JobID{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// CreateReviews the reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results
// of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.
//
// <h3>CallBack Schemas </h3>
// <h4>Review Completion CallBack Sample</h4>
// <p>
// {<br/>
// "ReviewId": "<Review Id>",<br/>
// "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
// "ModifiedBy": "<Name of the Reviewer>",<br/>
// "CallBackType": "Review",<br/>
// "ContentId": "<The ContentId that was specified input>",<br/>
// "Metadata": {<br/>
// "adultscore": "0.xxx",<br/>
// "a": "False",<br/>
// "racyscore": "0.xxx",<br/>
// "r": "True"<br/>
// },<br/>
// "ReviewerResultTags": {<br/>
// "a": "False",<br/>
// "r": "True"<br/>
// }<br/>
// }<br/>
//
// </p>.
//
// URLContentType is the content type. teamName is your team name. createReviewBody is body for create reviews API
// subTeam is subTeam of your team, you want to assign the created review to.
func (client ReviewsClient) CreateReviews(ctx context.Context, URLContentType string, teamName string, createReviewBody []CreateReviewBodyItem, subTeam *string) (*CreateReviewsResponse, error) {
	if err := validate([]validation{
		{targetValue: createReviewBody,
			constraints: []constraint{{target: "createReviewBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.createReviewsPreparer(URLContentType, teamName, createReviewBody, subTeam)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.createReviewsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*CreateReviewsResponse), err
}

// createReviewsPreparer prepares the CreateReviews request.
func (client ReviewsClient) createReviewsPreparer(URLContentType string, teamName string, createReviewBody []CreateReviewBodyItem, subTeam *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if subTeam != nil {
		params.Set("subTeam", *subTeam)
	}
	req.URL.RawQuery = params.Encode()
	req.Header.Set("UrlContentType", URLContentType)
	b, err := json.Marshal(createReviewBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// createReviewsResponder handles the response to the CreateReviews request.
func (client ReviewsClient) createReviewsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &CreateReviewsResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// CreateVideoReviews the reviews created would show up for Reviewers on your team. As Reviewers complete reviewing,
// results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.
//
// <h3>CallBack Schemas </h3>
// <h4>Review Completion CallBack Sample</h4>
// <p>
// {<br/>
// "ReviewId": "<Review Id>",<br/>
// "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
// "ModifiedBy": "<Name of the Reviewer>",<br/>
// "CallBackType": "Review",<br/>
// "ContentId": "<The ContentId that was specified input>",<br/>
// "Metadata": {<br/>
// "adultscore": "0.xxx",<br/>
// "a": "False",<br/>
// "racyscore": "0.xxx",<br/>
// "r": "True"<br/>
// },<br/>
// "ReviewerResultTags": {<br/>
// "a": "False",<br/>
// "r": "True"<br/>
// }<br/>
// }<br/>
//
// </p>.
//
// contentType is the content type. teamName is your team name. createVideoReviewsBody is body for create reviews API
// subTeam is subTeam of your team, you want to assign the created review to.
func (client ReviewsClient) CreateVideoReviews(ctx context.Context, contentType string, teamName string, createVideoReviewsBody []CreateVideoReviewsBodyItem, subTeam *string) (*CreateVideoReviewsResponse, error) {
	if err := validate([]validation{
		{targetValue: createVideoReviewsBody,
			constraints: []constraint{{target: "createVideoReviewsBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.createVideoReviewsPreparer(contentType, teamName, createVideoReviewsBody, subTeam)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.createVideoReviewsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*CreateVideoReviewsResponse), err
}

// createVideoReviewsPreparer prepares the CreateVideoReviews request.
func (client ReviewsClient) createVideoReviewsPreparer(contentType string, teamName string, createVideoReviewsBody []CreateVideoReviewsBodyItem, subTeam *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if subTeam != nil {
		params.Set("subTeam", *subTeam)
	}
	req.URL.RawQuery = params.Encode()
	req.Header.Set("Content-Type", contentType)
	b, err := json.Marshal(createVideoReviewsBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// createVideoReviewsResponder handles the response to the CreateVideoReviews request.
func (client ReviewsClient) createVideoReviewsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &CreateVideoReviewsResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetJobDetails get the Job Details for a Job Id.
//
// teamName is your Team Name. jobID is id of the job.
func (client ReviewsClient) GetJobDetails(ctx context.Context, teamName string, jobID string) (*Job, error) {
	req, err := client.getJobDetailsPreparer(teamName, jobID)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getJobDetailsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Job), err
}

// getJobDetailsPreparer prepares the GetJobDetails request.
func (client ReviewsClient) getJobDetailsPreparer(teamName string, jobID string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getJobDetailsResponder handles the response to the GetJobDetails request.
func (client ReviewsClient) getJobDetailsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Job{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetReview returns review details for the review Id passed.
//
// teamName is your Team Name. reviewID is id of the review.
func (client ReviewsClient) GetReview(ctx context.Context, teamName string, reviewID string) (*Review, error) {
	req, err := client.getReviewPreparer(teamName, reviewID)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getReviewResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Review), err
}

// getReviewPreparer prepares the GetReview request.
func (client ReviewsClient) getReviewPreparer(teamName string, reviewID string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getReviewResponder handles the response to the GetReview request.
func (client ReviewsClient) getReviewResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Review{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetVideoFrames the reviews created would show up for Reviewers on your team. As Reviewers complete reviewing,
// results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.
//
// <h3>CallBack Schemas </h3>
// <h4>Review Completion CallBack Sample</h4>
// <p>
// {<br/>
// "ReviewId": "<Review Id>",<br/>
// "ModifiedOn": "2016-10-11T22:36:32.9934851Z",<br/>
// "ModifiedBy": "<Name of the Reviewer>",<br/>
// "CallBackType": "Review",<br/>
// "ContentId": "<The ContentId that was specified input>",<br/>
// "Metadata": {<br/>
// "adultscore": "0.xxx",<br/>
// "a": "False",<br/>
// "racyscore": "0.xxx",<br/>
// "r": "True"<br/>
// },<br/>
// "ReviewerResultTags": {<br/>
// "a": "False",<br/>
// "r": "True"<br/>
// }<br/>
// }<br/>
//
// </p>.
//
// teamName is your team name. reviewID is id of the review. startSeed is time stamp of the frame from where you want
// to start fetching the frames. noOfRecords is number of frames to fetch. filter is get frames filtered by tags.
func (client ReviewsClient) GetVideoFrames(ctx context.Context, teamName string, reviewID string, startSeed *int32, noOfRecords *int32, filter *string) (*Frames, error) {
	req, err := client.getVideoFramesPreparer(teamName, reviewID, startSeed, noOfRecords, filter)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getVideoFramesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Frames), err
}

// getVideoFramesPreparer prepares the GetVideoFrames request.
func (client ReviewsClient) getVideoFramesPreparer(teamName string, reviewID string, startSeed *int32, noOfRecords *int32, filter *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if startSeed != nil {
		params.Set("startSeed", fmt.Sprintf("%v", *startSeed))
	}
	if noOfRecords != nil {
		params.Set("noOfRecords", fmt.Sprintf("%v", *noOfRecords))
	}
	if filter != nil {
		params.Set("filter", *filter)
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getVideoFramesResponder handles the response to the GetVideoFrames request.
func (client ReviewsClient) getVideoFramesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Frames{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// PublishVideoReview publish video review to make it available for review.
//
// teamName is your team name. reviewID is id of the review.
func (client ReviewsClient) PublishVideoReview(ctx context.Context, teamName string, reviewID string) (*http.Response, error) {
	req, err := client.publishVideoReviewPreparer(teamName, reviewID)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.publishVideoReviewResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// publishVideoReviewPreparer prepares the PublishVideoReview request.
func (client ReviewsClient) publishVideoReviewPreparer(teamName string, reviewID string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// publishVideoReviewResponder handles the response to the PublishVideoReview request.
func (client ReviewsClient) publishVideoReviewResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusNoContent)
	if resp == nil {
		return nil, err
	}
	return resp, err
}
