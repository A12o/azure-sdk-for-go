package contentmoderator

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-pipeline-go/pipeline"
	"io/ioutil"
	"net/http"
	"net/url"
)

// ListManagementTermClient is the you use the API to scan your content as it is generated. Content Moderator then
// processes your content and sends the results along with relevant information either back to your systems or to the
// built-in review tool. You can use this information to take decisions e.g. take it down, send to human judge, etc.
//
// When using the API, images need to have a minimum of 128 pixels and a maximum file size of 4MB.
// Text can be at most 1024 characters long.
// If the content passed to the text API or the image API exceeds the size limits, the API will return an error code
// that informs about the issue.
//
// This API is currently available in:
//
// * West US - westus.api.cognitive.microsoft.com
// * East US 2 - eastus2.api.cognitive.microsoft.com
// * West Central US - westcentralus.api.cognitive.microsoft.com
// * West Europe - westeurope.api.cognitive.microsoft.com
// * Southeast Asia - southeastasia.api.cognitive.microsoft.com .
type ListManagementTermClient struct {
	ManagementClient
}

// NewListManagementTermClient creates an instance of the ListManagementTermClient client.
func NewListManagementTermClient(url url.URL, p pipeline.Pipeline) ListManagementTermClient {
	return ListManagementTermClient{NewManagementClient(url, p)}
}

// AddTerm add a term to the term list with list Id equal to list Id passed.
//
// listID is list Id of the image list. term is term to be deleted language is language of the terms.
func (client ListManagementTermClient) AddTerm(ctx context.Context, listID string, term string, language string) (*AddTermResponse, error) {
	req, err := client.addTermPreparer(listID, term, language)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.addTermResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*AddTermResponse), err
}

// addTermPreparer prepares the AddTerm request.
func (client ListManagementTermClient) addTermPreparer(listID string, term string, language string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("language", language)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// addTermResponder handles the response to the AddTerm request.
func (client ListManagementTermClient) addTermResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusCreated)
	if resp == nil {
		return nil, err
	}
	result := &AddTermResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// DeleteAllTerms deletes all terms from the list with list Id equal to the list Id passed.
//
// listID is list Id of the image list. language is language of the terms.
func (client ListManagementTermClient) DeleteAllTerms(ctx context.Context, listID string, language string) (*DeleteAllTermsResponse, error) {
	req, err := client.deleteAllTermsPreparer(listID, language)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteAllTermsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DeleteAllTermsResponse), err
}

// deleteAllTermsPreparer prepares the DeleteAllTerms request.
func (client ListManagementTermClient) deleteAllTermsPreparer(listID string, language string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("DELETE", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("language", language)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// deleteAllTermsResponder handles the response to the DeleteAllTerms request.
func (client ListManagementTermClient) deleteAllTermsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusNoContent)
	if resp == nil {
		return nil, err
	}
	result := &DeleteAllTermsResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// DeleteTerm deletes a term from the list with list Id equal to the list Id passed.
//
// listID is list Id of the image list. term is term to be deleted language is language of the terms.
func (client ListManagementTermClient) DeleteTerm(ctx context.Context, listID string, term string, language string) (*DeleteTermResponse, error) {
	req, err := client.deleteTermPreparer(listID, term, language)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteTermResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DeleteTermResponse), err
}

// deleteTermPreparer prepares the DeleteTerm request.
func (client ListManagementTermClient) deleteTermPreparer(listID string, term string, language string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("DELETE", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("language", language)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// deleteTermResponder handles the response to the DeleteTerm request.
func (client ListManagementTermClient) deleteTermResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusNoContent)
	if resp == nil {
		return nil, err
	}
	result := &DeleteTermResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetAllTerms gets all terms from the list with list Id equal to the list Id passed.
//
// listID is list Id of the image list. language is language of the terms. offset is the pagination start index. limit
// is the max limit.
func (client ListManagementTermClient) GetAllTerms(ctx context.Context, listID string, language string, offset *int32, limit *int32) (*Terms, error) {
	req, err := client.getAllTermsPreparer(listID, language, offset, limit)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getAllTermsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Terms), err
}

// getAllTermsPreparer prepares the GetAllTerms request.
func (client ListManagementTermClient) getAllTermsPreparer(listID string, language string, offset *int32, limit *int32) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("language", language)
	if offset != nil {
		params.Set("offset", fmt.Sprintf("%v", *offset))
	}
	if limit != nil {
		params.Set("limit", fmt.Sprintf("%v", *limit))
	}
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getAllTermsResponder handles the response to the GetAllTerms request.
func (client ListManagementTermClient) getAllTermsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Terms{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}
